"use strict";

//------------------------------------------------------------------------------

Object.defineProperty(exports, "__esModule", { value: true });

//------------------------------------------------------------------------------

const childProcess = require("child_process");
const fs = require("fs");
const os = require("os");
const path = require("path");
const process = require("process");
const tmp = require("tmp");
const vscode = require("vscode");
const WinReg = require("winreg");

//==============================================================================
// #region Constants

    // --- VSCode Arduino Extension ---

const ARDUINO_CONFIG_FILE = path.join(".vscode", "arduino.json");

const ARDUINO_PATH = "arduino.path";                        // Location of arduino executable
const PYTHON_PYTHONPATH = "python.pythonPath";              // Python Executable

    // --- new items ---

const ESP8266FS_DATAFILES    = "esp8266fs.dataFiles";       // Location of SPIFFS files
const ESP8266FS_PREFERENCES  = "esp8266fs.preferencesPath"; // Location of Arduino Custom Packages
const ESP8266FS_SPIFFS_IMAGE = "esp8266fs.spiffsImage";     // Packed SPIFFS file
const ESP8266FS_LOGLEVEL     = "esp8266fs.logLevel";        // Level of spew generated by this extension

const ESP8266FS_MKSPIFFS_EXECUTABLE  = "esp8266fs.mkspiffs.executable"; // MKSPIFFS Executable
const ESP8266FS_MKSPIFFS_DEBUG_LEVEL = "esp8266fs.mkspiffs.debugLevel"; // Value passed to MKSPIFFS Executable
const ESP8266FS_MKSPIFFS_ALL_FILES   = "esp8266fs.mkspiffs.allFiles";   // Value passed to MKSPIFFS Executable

const ESP8266FS_ESPTOOL_EXECUTABLE = "esp8266fs.esptool.executable"; // ESPTOOL Executable
const ESP8266FS_ESPTOOL_VERBOSITY  = "esp8266fs.esptool.verbosity";  // Value passed to ESPTOOL Executable

const ESP8266FS_ESPOTA_PY        = "esp8266fs.espota.py";        // EspOTA Python script
const ESP8266FS_ESPOTA_ESP_PORT  = "esp8266fs.espota.esp.port";  // IP Port for ESP8266
const ESP8266FS_ESPOTA_HOST_IP   = "esp8266fs.espota.host.ip";   // IP Address for Host
const ESP8266FS_ESPOTA_HOST_PORT = "esp8266fs.espota.host.port"; // IP Port for Host
const ESP8266FS_ESPOTA_AUTH      = "esp8266fs.espota.auth";      // Authentication password for espota.py
const ESP8266FS_ESPOTA_DEBUG     = "esp8266fs.espota.debug";     // Enable debug output from espota.py

// #endregion

//==============================================================================
// #region Logging

const RESET    = "\u001b[0m";
const BOLD     = "\u001b[1m";

const RED      = "\u001b[31m";
const GREEN    = "\u001b[32m";
const YELLOW   = "\u001b[33m";
const BLUE     = "\u001b[34m";
const MAGENTA  = "\u001b[35m";
const CYAN     = "\u001b[36m";

const BOLD_RED = "\u001b[31;1m";

//------------------------------------------------------------------------------

let outputChannel = null;
let logLevel = "normal"; // "normal", "verbose", "silent", "debug"

function log(message, color) {
    if (logLevel === "silent")
        return;

    if (color)
        console.log(`${color}${message}${RESET}`);
    else
        console.log(message);

    outputChannel.appendLine(message.replace(/\x1b\[[\d|\;]{1,4}m/g, ""));
    outputChannel.show();
}

//------------------------------------------------------------------------------

function logAnnounce(message)  { log(message, GREEN); }
function logUrgent(message)    { log(message, BOLD_RED); }
function logImportant(message) { log(message, RED); }
function logCommand(message)   { log(message, YELLOW); }
function logSpiffs(message)    { log(`  [SPIFFS] ${message}`, BLUE); }

//------------------------------------------------------------------------------

function logVerbose(message)
{
    if (logLevel === "verbose" || logLevel === "debug")
        log(message, MAGENTA);
}

//------------------------------------------------------------------------------

function logDebug(message)
{
    if (logLevel === "debug")
        log(message, CYAN);
}

//------------------------------------------------------------------------------

function showErrorMessage(message)
{
    const dismiss = { isCloseAffordance: true, title: "Dismiss" };

    vscode.window.showErrorMessage(message, dismiss);
}

//------------------------------------------------------------------------------

function showWarningMessage(message)
{
    vscode.window.showWarningMessage(message);
}

//------------------------------------------------------------------------------

function showInformationMessage(message)
{
    vscode.window.showInformationMessage(message);
}

// #endregion

//==============================================================================
// #region Helper functions

function stringToInt(value) {
    return parseInt(value, value.match(/^0x/i) ? 16 : 10);
}

//------------------------------------------------------------------------------

function toHex(decimal, width = 4) {
    return ("0".repeat(width) + (Number(decimal).toString(16))).slice(-width).toUpperCase();
}

//------------------------------------------------------------------------------

function makeOsPath(dir) {
    dir = dir.replace(/\\/g, "/");

    if (dir.indexOf(" ") != -1)
        dir = `"${dir}"`;

    return dir;
}

// #endregion

//==============================================================================
// #region Utility functions

function getVscodeConfigValue(key) {
    return vscode.workspace.getConfiguration().get(key);
}

//------------------------------------------------------------------------------

function getOS() { return os.platform(); }

//------------------------------------------------------------------------------

function program(name) {
    return (getOS() === "win32" && name.indexOf(".") == -1)
        ? (name + ".exe")
        : name;
}

//------------------------------------------------------------------------------

function runCommand(command, args) {
    logVerbose("Running: " + command + " " + args.join(" "));

    const spawn = childProcess.spawnSync(command, args, { encoding: "utf8" });

    if (spawn.error)
        throw spawn.error;

    spawn.stdout
        .toString()
        .replace(/\r\n/, "\n")
        .split("\n")
        .forEach(line => logCommand(line.trimRight()));

    spawn.stderr
        .toString()
        .replace(/\r\n/, "\n")
        .split("\n")
        .forEach(line => logUrgent(line.trimRight()));

    if (spawn.status)
        throw `${command} returned ${spawn.status}`;

    return spawn.stdout.toString();
}

//-------------------------------------------------------------------------------

function getTempPath() {
    const temp = tmp.dirSync();

    logDebug(`System tmp path: "${temp}"`);

    return temp;
}

//------------------------------------------------------------------------------

function dirExists(dir) {
    try {
        return fs.statSync(dir).isDirectory();
    }
    catch (e) {
        return false;
    }
}

//------------------------------------------------------------------------------

function getFolders(dir) {
    return fs.readdirSync(dir);
}

//------------------------------------------------------------------------------

function fileExists(file) {
    try {
        return fs.statSync(file).isFile();
    }
    catch (e) {
        return false;
    }
}

//------------------------------------------------------------------------------

function readFile(name) {
    return fs.readFileSync(name, "utf8");
}

//------------------------------------------------------------------------------

function readLines(name) {
    return readFile(name).split(/[\r\n|\r|\n]/);
}

//------------------------------------------------------------------------------

function JSONify(obj) {
    return JSON.stringify(obj, null, " ");
}

//------------------------------------------------------------------------------

function getRegistryValue(hive, key, name) {
    return new Promise((resolve, reject) => {
        try {
            const regKey = new WinReg({
                hive,
                key,
            });

            regKey.valueExists(name, (e, exists) => {
                if (e) {
                    reject(e);
                }

                if (exists) {
                    regKey.get(name, (err, result) => {
                        if (!err) {
                            resolve(result ? result.value : "");
                        } else {
                            reject(err);
                        }
                    });
                } else {
                    resolve("");
                }
            });
        } catch (error) {
            reject(error);
        }
    });
}

// #endregion

//==============================================================================
// #region ESP8266FS Specific code
//==============================================================================

const ARDUINO_X32_REG_KEY = "\\SOFTWARE\\Arduino";
const ARDUINO_X64_REG_KEY = "\\SOFTWARE\\WOW6432Node\\Arduino";

async function getArduinoInstallPath() {
    switch (getOS()) {
        case "win32": {
            let dir = await getRegistryValue(WinReg.HKLM,
                (process.arch === "x64" ||
                 process.env.hasOwnProperty("PROCESSOR_ARCHITEW6432"))
                    ? ARDUINO_X64_REG_KEY
                    : ARDUINO_X32_REG_KEY,
                "Install_Dir");

            if (!dir)
                throw `Can't find Arduino Registry Key`;

            dir = path.resolve(dir);

            if (dirExists(dir)) {
                return dir;
            }
            try {
                const file = path.resolve((runCommand("where",  [ "arduino" ]))).trim();

                file = path.resolve(file);

                if (fileExists(file)) {
                    return path.dirname(file);
                }
            }
            catch (error) {
            }

            break;
        }

        case "darwin": {
            const dir = [
                    path.join(process.env.HOME, "Applications"),
                    "/Applications"
                ].find(d => dirExists(path.join(d, "Arduino.app")));

            if (dir)
                return dir;

            break;
        }

        case "linux": {
            try {
                const file = path.resolve(runCommand("readlink", [ "-f", "$(which arduino)" ])).trim();

                if (fileExists(file))
                    return path.dirname(file);
            }
            catch (ex) { // Ignore the errors.
            }

            break;
        }
    }

    throw "Can't find Arduino executable.";
}

//------------------------------------------------------------------------------

async function getArduinoPath() {
    let dir = getVscodeConfigValue(ARDUINO_PATH) || await getArduinoInstallPath();

    if (!dir)
        throw "Can't find Arduino path.";

    dir = path.resolve(dir);

    if (!dirExists(dir))
        throw `Arduino path "${dir} " doesn't exist.`;

    logVerbose(`Arduino path: "${dir}"`);
    return dir;
}

//-------------------------------------------------------------------------------

const USER_SHELL_FOLDERS = "\\Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\User Shell Folders";

function getPreferencesPath() {
    let dir = getVscodeConfigValue(ESP8266FS_PREFERENCES);

    if (!dir) {
        switch (getOS()) {
            case "win32":
                dir = path.join(process.env.LOCALAPPDATA, "Arduino15");
                break;

            case "linux":
                dir = path.join(process.env.HOME, ".arduino15");
                break;

            case "darwin":
                dir = path.join(process.env.HOME, "Library/Arduino15");
                break;
        }
    }

    if (!dir)
        throw "Can't find preferences path.";

    dir = path.resolve(dir);

    if (!dirExists(dir))
        throw `Preferences path "${dir}" doesn't exist.`;

    logVerbose(`Preferences Path: "${dir}"`);
    return dir;
}

//-------------------------------------------------------------------------------

function getDataFilesPath(arduinoJson) {
    let dir = getVscodeConfigValue(ESP8266FS_DATAFILES) || "./data";

    if (dir.startsWith("."))
        dir = path.join(vscode.workspace.rootPath, dir);

    dir = path.resolve(dir);

    if (!dirExists(dir))
        throw `ESP8266 Data Files path "${dir}" not found.`;

    logVerbose(`ESP8266 Data Files path: "${dir}"`);

    return dir;
}

//-------------------------------------------------------------------------------

function getSpiffsImage() {
    let file = getVscodeConfigValue(ESP8266FS_SPIFFS_IMAGE)
        ||path.join(getTempPath(), "./spiffs.bin");

    if (file.startsWith("."))
        file = path.join(vscode.workspace.rootPath, file);

    file = path.resolve(file);

    logVerbose(`SPIFFS Image: "${file}"`);
    return file;
}

//-------------------------------------------------------------------------------

async function getArduinoPreferences(preferencesPath) {
    const preferences = {};

    const file = path.join(preferencesPath, "preferences.txt");
    logVerbose(`Reading preferences from "${file}"`);

    readLines(file)
        .forEach(line => {
            if (line.startsWith("#") || line.length == 0)
                return;

            const pair = line.split("=");

            logDebug(`  "${pair[0]}"="${pair[1]}"`);
            preferences[pair[0]] = pair[1];
        }
    );

    return preferences;
}

//-------------------------------------------------------------------------------

async function getArduinoJson() {
    var json = JSON.parse(readFile(path.join(vscode.workspace.rootPath, ARDUINO_CONFIG_FILE)));

        // Split the configuration settings into key/values

    if (json.configuration) {
        json.configuration.split(",").forEach(config => {
            let param = config.split("=");

            json[param[0]] = param[1];
        });
    }

    logDebug(`arduinoJson:`);
    JSONify(json).split("\n").map(line => logDebug(line));

    return json;
}
//-------------------------------------------------------------------------------

function _getTarget(arduinJson, preferences) {
    if (!arduinJson.board) {
        const target =
            {
                package: preferences["target_package"],
                architecture: preferences["target_platform"],
                board: preferences["board"]
            };

        return target;
    }

    const values = arduinJson.board.split(":");

    const target =
        {
            package: values[0],
            architecture: values[1],
            board: values[2]
        };

    return target;
}

//------------------------------------------------------------------------------

function getTarget(arduinJson, preferences) {
    const target = _getTarget(arduinJson, preferences);

    if (target.package !== "esp8266" || target.architecture !== "esp8266")
        throw "Current Arduino package/architecture is not ESP8266.";

    logDebug(`target:`);
    JSONify(target).split("\n").map(line => logDebug(line));

    return target;
}

//------------------------------------------------------------------------------

function _getMemoryConfiguration(arduinoJson, preferences, target) {
    if (arduinoJson.FlashSize)
        return arduinoJson.FlashSize;

    const flashSize = preferences["custom_FlashSize"];

    if (flashSize) {
        const match = flashSize.match(/^${target.board}_(\S+)/);

        if (match)
            return match[1];
    }

    throw "Can't determine Flash Size.";
}

//------------------------------------------------------------------------------

function getMemoryConfiguration(arduinoJson, preferences, target) {
    const config = _getMemoryConfiguration(arduinoJson, preferences, target);

    logVerbose(`Memory Config: ${config}`);
    return config;
}

//------------------------------------------------------------------------------

function getEsp8266PackagePath(preferencesPath, target) {
    const dir = path.join(preferencesPath, "packages", target.package, "hardware", target.architecture);

    if (!dirExists(dir))
        throw "ESP8266 has not been installed with the Arduino Board Manager.";

    const folders = getFolders(dir);

    if (folders.length != 1)
        throw "There should only be one ESP8266 Package installed with the Arduino Board Manager.";

    logImportant(`Found ESP8266 version ${folders[0]}`);
    return path.join(dir, folders[0]);
}

//------------------------------------------------------------------------------

function getSpiffsOptions(packagesPath, target, memoryConfig, arduinoJson) {
    const spiffs = {};

    readLines(path.join(packagesPath, "boards.txt"))
        .forEach(line => {
            const match = line.match(`${target.board}\\.(?:build|upload)\\.(\\S+)=(\\S+)`)
                       || line.match(`${target.board}\\.menu\\.FlashSize\\.${memoryConfig}\\.(?:build|upload)\\.(\\S+)=(\\S+)`)

            if (match)
                spiffs[match[1]] = match[2];
        }
    );

    if (!spiffs.spiffs_start)
        throw `Missing "spiffs_start" definition: target = ${target}, config = ${memoryConfig}.`;

    if (!spiffs.spiffs_end)
        throw `Missing "spiffs_end" definition: target = ${target}, config = ${memoryConfig}.`;

    if (arduinoJson.UploadSpeed)
        spiffs.speed = arduinoJson.UploadSpeed;

    if (arduinoJson.ResetMethod)
        spiffs.resetmethod = arduinoJson.ResetMethod;

    logDebug(`spiffs:`);
    JSONify(spiffs).split("\n").map(line => logDebug(line));

    return spiffs;
}

//------------------------------------------------------------------------------

function getToolPath(toolsPath, tool, configValue) {
    let configFile = getVscodeConfigValue(configValue);

    if (configFile) {
        if (!fileExists(configFile))
            throw `Can't locate ${configFile}.`;

        logVerbose(`${tool}: ${CYAN}${configFile}`);
        logImportant(`Found ${tool} via VSCode Configuration`);

        return configFile;
    }

    const dir = path.join(toolsPath, tool);

    if (!dirExists(dir))
        throw `Can't locate "${tool}" path`;

    const folders = getFolders(dir);

    if (folders.length != 1)
        throw `There should only be one ESP8266 "${tool}" tool installed with the Arduino Board Manager.`;

    const file = path.join(dir, folders[0], program(tool));

    if (!fileExists(file))
        throw `Can't locate ${file}.`;

    logVerbose(`${tool}: ${CYAN}${file}`);
    logImportant(`Found ${tool} version ${folders[0]}`);
    return file;
}

//------------------------------------------------------------------------------

function getToolsPath(preferencesPath, target) {
    const dir = path.resolve(path.join(preferencesPath, "packages", target.package, "tools"));

    if (!dirExists(dir))
        throw `Can't find ESP8266 tools path.`;

    logVerbose(`Tools Path: "${dir}"`);
    return dir;
}

//------------------------------------------------------------------------------

function getPythonExecutable() {
    const python = getVscodeConfigValue(PYTHON_PYTHONPATH) || "python";

    logVerbose(`Python Executable: "${python}"`);
    return python;
}

//------------------------------------------------------------------------------

function getEspotaPy(packagePath) {
    const file = getVscodeConfigValue(ESP8266FS_ESPOTA_PY) || path.join(packagePath, "tools", "espota.py");

    if (!fileExists(file))
        throw `Can't find ${file}.`;

    logVerbose(`espota.py: ${CYAN}${file}`);
    return file;
}

//------------------------------------------------------------------------------

function getPort(arduinoJson, preferences) {
    let port = arduinoJson.port || preferences["serial.port"];

    logVerbose(`Output Port: ${port}`);
    return port;
}

//------------------------------------------------------------------------------

function isIP(port) {
    return port.match(/^(\d+)\.(\d+).(\d+).(\d+)(:\d+)?$/);
}

// #endregion

//==============================================================================
// #region MKSPIFFS

function makeMkspiffsArgs(args) {
    const allFiles = getVscodeConfigValue(ESP8266FS_MKSPIFFS_ALL_FILES);

    if (allFiles)
        args.unshift("--all-files", allFiles);

    const debug = getVscodeConfigValue(ESP8266FS_MKSPIFFS_DEBUG_LEVEL);

    if (debug)
        args.unshift("--debug", debug);

    return args;
}

//------------------------------------------------------------------------------

function packSpiffs(mkspiffs, dataPath, spiffsOptions, spiffsImage) {
    log(`--- Packing SPIFFS file ---`);

    const dataSize = stringToInt(spiffsOptions.spiffs_end) - stringToInt(spiffsOptions.spiffs_start);
    const dataSizeInK = dataSize >> 10;
    const spiPage = stringToInt(spiffsOptions.spiffs_pagesize || "256");
    const spiBlock = stringToInt(spiffsOptions.spiffs_blocksize || "4096");

    logImportant(`SPIFFS Creating Image... (${spiffsImage})`);
    logSpiffs(`program: ${mkspiffs}`);
    logSpiffs(`data   : ${dataPath}`);
    logSpiffs(`size   : ${dataSizeInK}K`);
    logSpiffs(`page   : ${spiPage}`);
    logSpiffs(`block  : ${spiBlock}`);

    runCommand(
        makeOsPath(mkspiffs),
        makeMkspiffsArgs([
            "--create", makeOsPath(dataPath),
            "--size", dataSize,
            "--page", spiPage,
            "--block", spiBlock,
            makeOsPath(spiffsImage)
        ])
    );
}

//------------------------------------------------------------------------------

function unpackSpiffs(mkspiffs, dataPath, spiffsOptions, spiffsImage) {
    log(`--- Unpacking SPIFFS file ---`);

    const dataSize = stringToInt(spiffsOptions.spiffs_end) - stringToInt(spiffsOptions.spiffs_start);
    const dataSizeInK = dataSize >> 10;
    const spiPage = stringToInt(spiffsOptions.spiffs_pagesize || "256");
    const spiBlock = stringToInt(spiffsOptions.spiffs_blocksize || "4096");

    logImportant(`SPIFFS Unpacking Image... (${spiffsImage})`);
    logSpiffs(`program: ${mkspiffs}`);
    logSpiffs(`data   : ${dataPath}`);
    logSpiffs(`size   : ${dataSizeInK}K`);
    logSpiffs(`page   : ${spiPage}`);
    logSpiffs(`block  : ${spiBlock}`);

    runCommand(
        makeOsPath(mkspiffs),
        makeMkspiffsArgs([
            "--unpack", makeOsPath(dataPath),
            "--size", dataSize,
            "--page", spiPage,
            "--block", spiBlock,
            makeOsPath(spiffsImage)
        ])
    );
}

//------------------------------------------------------------------------------

function listSpiffs(mkspiffs, spiffsOptions, spiffsImage) {
    log(`--- List SPIFFS file ---`);

    const spiPage = stringToInt(spiffsOptions.spiffs_pagesize || "256");
    const spiBlock = stringToInt(spiffsOptions.spiffs_blocksize || "4096");

    logImportant(`SPIFFS List Files... (${spiffsImage})`);
    logSpiffs(`program: ${mkspiffs}`);
    logSpiffs(`page   : ${spiPage}`);
    logSpiffs(`block  : ${spiBlock}`);

    runCommand(
        makeOsPath(mkspiffs),
        makeMkspiffsArgs([
            "--list",
            "--page", spiPage,
            "--block", spiBlock,
            makeOsPath(spiffsImage)
        ])
    );
}

//------------------------------------------------------------------------------

function visualizeSpiffs(mkspiffs, spiffsOptions, spiffsImage) {
    log(`--- Visualize SPIFFS file ---`);

    const spiPage = stringToInt(spiffsOptions.spiffs_pagesize || "256");
    const spiBlock = stringToInt(spiffsOptions.spiffs_blocksize || "4096");

    logImportant(`SPIFFS Visualize Files... (${spiffsImage})`);
    logSpiffs(`program: ${mkspiffs}`);
    logSpiffs(`page   : ${spiPage}`);
    logSpiffs(`block  : ${spiBlock}`);

    runCommand(
        makeOsPath(mkspiffs),
        makeMkspiffsArgs([
            "--visualize",
            "--page", spiPage,
            "--block", spiBlock,
            makeOsPath(spiffsImage)
        ])
    );
}

// #endregion

//==============================================================================
// #region ESPTOOL

function uploadSpiffs(esptool, spiffsOptions, commPort, spiffsImage) {
    log(`--- Uploading SPIFFS file ---`);

    const uploadAddress = `0x` + toHex(stringToInt(spiffsOptions.spiffs_start), 6);
    const uploadSpeed = stringToInt(spiffsOptions.speed);
    const resetMethod = spiffsOptions.resetmethod;

    logImportant(`SPIFFS Uploading Image... (${spiffsImage})`);
    logSpiffs(`program: ${esptool}`);
    logSpiffs(`address: ${uploadAddress}`);
    logSpiffs(`reset  : ${resetMethod}`);
    logSpiffs(`port   : ${commPort}`);
    logSpiffs(`speed  : ${uploadSpeed}`);

    let args = [
        "-ca", uploadAddress,          // Address in flash.
        "-cd", resetMethod,            // Board reset method: "none", "ck", "nodemcu", or "wifio".
        "-cp", commPort,               // Serial Port (Default Linux: /dev/ttyUSB0, Windows: COM1, OSx: /dev/tty.usbserial).
        "-cb", uploadSpeed,            // Baud rate (Default: 115200).
        "-cf", makeOsPath(spiffsImage) // SPIFFS File
    ];

    const verbosity = getVscodeConfigValue(ESP8266FS_ESPTOOL_VERBOSITY);

    if (verbosity)
        args.unshift(`-${verbosity}`);

    runCommand(makeOsPath(esptool), args);
}

// #endregion

//==============================================================================
// #region ESPOTA.PY

// --ip <address>
// --port <port>         default: 8266
// --host_ip <address>   default: 0.0.0.0
// --host_port <port>    default: random(10000, 60000)
// --auth <password>
// --spiffs
// --file <image>
// --debug

function uploadSpiffsOta(python, espota, ip, spiffsImage) {
    log(`--- Uploading SPIFFS file via OTA ---`);

    let port = 8266;

    if (ip.indexOf(":") != -1)
        [ ip, port ] = ip.split(":");

    port = getVscodeConfigValue(ESP8266FS_ESPOTA_ESP_PORT) || port;

    let host = getVscodeConfigValue(ESP8266FS_ESPOTA_HOST_IP);
    let host_port = "";

    if (host.indexOf(":") != -1)
        [ host, host_port ] = host.split(":");

    host_port = getVscodeConfigValue(ESP8266FS_ESPOTA_HOST_PORT) || host_port;

    logImportant(`SPIFFS Uploading Image... (${spiffsImage})`);
    logSpiffs(`Python   : ${python}`);
    logSpiffs(`EspOTA   : ${espota}`);
    logSpiffs(`IP       : ${ip}`);
    logSpiffs(`Port     : ${port}`);
    logSpiffs(`Host IP  : ${host}`);
    logSpiffs(`Host Port: ${host_port}`);

    let args = [
        makeOsPath(espota),               // Python code
        "--ip",     ip                    // IP address
    ];

    if (port)
        args.push("--port", port);

    if (host)
        args.push("--host_ip", host);

    if (host_port)
        args.push("--host_port", host_port);

    let auth = getVscodeConfigValue(ESP8266FS_ESPOTA_AUTH);

    if (auth)
        args.push("--auth", auth);

    if (getVscodeConfigValue(ESP8266FS_ESPOTA_DEBUG))
        args.push("--debug");

    args.push(
        "--spiffs",                       // Sending SPIFFS - do not FLASH!
        "--file",   makeOsPath(spiffsImage)
    );

    runCommand(makeOsPath(python), args);
}

// #endregion

//==============================================================================
// #region VSCode Command Handlers

async function _executeSpiffs(command) {
    const executable = await getArduinoPath();
    const preferencesPath = await getPreferencesPath();
    const preferences = await getArduinoPreferences(preferencesPath);
    const arduinoJson = await getArduinoJson();

    const target = getTarget(arduinoJson, preferences);

    const dataPath = getDataFilesPath(arduinoJson);
    const spiffsImage = getSpiffsImage();

    const memoryConfig = getMemoryConfiguration(arduinoJson, preferences, target);

    const esp8266packagePath = getEsp8266PackagePath(preferencesPath, target);

    const spiffsOptions = getSpiffsOptions(esp8266packagePath, target, memoryConfig, arduinoJson);

    const toolsPath = getToolsPath(preferencesPath, target);

    const port = getPort(arduinoJson, preferences);

    const mkspiffs = getToolPath(toolsPath, "mkspiffs", ESP8266FS_MKSPIFFS_EXECUTABLE);

        // --- Ready to get down to business ---

    switch (command) {
        case "upload": {
            packSpiffs(mkspiffs, dataPath, spiffsOptions, spiffsImage);

            if (isIP(port)) {
                const python = program(getPythonExecutable());
                const espota = getEspotaPy(esp8266packagePath);

                uploadSpiffsOta(python, espota, port, spiffsImage);
            }
            else {
                const esptool = getToolPath(toolsPath, "esptool", ESP8266FS_ESPTOOL_EXECUTABLE);

                uploadSpiffs(esptool, spiffsOptions, port, spiffsImage);
            }

            break;
        }

        case "pack":
            packSpiffs(mkspiffs, dataPath, spiffsOptions, spiffsImage);
            break;

        case "unpack":
            unpackSpiffs(mkspiffs, dataPath, spiffsOptions, spiffsImage);
            break;

        case "list":
            listSpiffs(mkspiffs, spiffsOptions, spiffsImage);
            break;

        case "visualize":
            visualizeSpiffs(mkspiffs, spiffsOptions, spiffsImage);
            break;
    }
}

//------------------------------------------------------------------------------

var locked = null;

async function executeSpiffs(command) {
    if (locked) {
        showErrorMessage(`ESP8266FS already running "${locked}"!`);
        return;
    }

    logLevel = getVscodeConfigValue(ESP8266FS_LOGLEVEL) || logLevel;

    logAnnounce(`ESP8266 SPIFFS interface started: "${command}".`);
    locked = command;

    try {
        await _executeSpiffs(command);
        showInformationMessage(`ESP266FS "${command}" completed!`);
    } catch (error) {
        logUrgent(error);
        showErrorMessage(error);
    }

    logAnnounce(`ESP8266 SPIFFS interface finished.`);
    locked = null;
}

//------------------------------------------------------------------------------

async function activate(context) {
    outputChannel = vscode.window.createOutputChannel("ESP8266FS");
    logLevel = getVscodeConfigValue(ESP8266FS_LOGLEVEL) || "normal";
    logVerbose(`ESP8266FS is now active!`);

    context.subscriptions.push(vscode.commands.registerCommand('esp8266fs.uploadSpiffs',    () => { executeSpiffs("upload"); }));
    context.subscriptions.push(vscode.commands.registerCommand('esp8266fs.packSpiffs',      () => { executeSpiffs("pack"); }));
    context.subscriptions.push(vscode.commands.registerCommand('esp8266fs.unpackSpiffs',    () => { executeSpiffs("unpack"); }));
    context.subscriptions.push(vscode.commands.registerCommand('esp8266fs.listSpiffs',      () => { executeSpiffs("list"); }));
    context.subscriptions.push(vscode.commands.registerCommand('esp8266fs.visualizeSpiffs', () => { executeSpiffs("visualize"); }));
}

exports.activate = activate;

//------------------------------------------------------------------------------

function deactivate() {}

exports.deactivate = (() => {});

// #endregion
